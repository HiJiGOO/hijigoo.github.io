<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>안녕지구</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2018-12-21T01:42:09+09:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>안녕지구</name>
   <email></email>
 </author>

 
 <entry>
   <title>주사위 프로젝트 - 프로젝트 생성</title>
   <link href="http://localhost:4000/bixby/2018/12/21/basic_tutorial_1/"/>
   <updated>2018-12-21T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/21/basic_tutorial_1</id>
   <content type="html">&lt;p&gt;안녕하세요. 이번에는 빅스비 개발자 홈페이지에 나와있는 &lt;a href=&quot;https://bixbydevelopers.com/dev/docs/get-started/quick-start&quot;&gt;Dice 프로젝트&lt;/a&gt;를 만들어 보려고 합니다. 영어가 편하신분은 공식 사이트에서 보시는 것을 추천드립니다. Dice프로젝트는 사용자가 아래와 같이 말하면 그 결과를 보여주는 간단한 캡슐입니다. 아래 예제에서 숫자 4 와 2는 1~6 중에서 랜덤으로 나온 숫자입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사용자: “&lt;strong&gt;면이 6개&lt;/strong&gt;인 &lt;strong&gt;주사위 2개&lt;/strong&gt;를 굴려줘!”&lt;br /&gt;
빅스비: “4 그리고 2 가 나왔습니다. 총 합은 6입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;프로젝트-생성&quot;&gt;프로젝트 생성&lt;/h2&gt;

&lt;p&gt;그럼 프로젝트를 만들어 보겠습니다. IDE는 &lt;a href=&quot;https://bixbydevelopers.com/&quot;&gt;공식 홈페이지&lt;/a&gt;에서 자신이 사용하는 OS에 맞게 &lt;a href=&quot;https://bixbydevelopers.com/&quot;&gt;다운&lt;/a&gt; 받으시면 됩니다. IDE를 설치하시고 아래와 같은 순서로 진행합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Fie-&amp;gt;New Capsule&lt;/strong&gt;을 선택하여 프로젝트를 생성합니다.&lt;/li&gt;
  &lt;li&gt;프로젝트를 생성할 폴더를 선택합니다.&lt;/li&gt;
  &lt;li&gt;Capsule ID를 입력합니다. 저는 &lt;strong&gt;study.dice&lt;/strong&gt;로 생성했습니다.&lt;/li&gt;
  &lt;li&gt;마지막으로 &lt;strong&gt;Create&lt;/strong&gt; 버튼을 누르시면 기본 구조로 프로젝트가 생성됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-21-basic_tutorial_1/screenshot01.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 프로젝트를 생성하면 code와 resources폴더가 생깁니다. code폴더에는 Javascript 코드가 들어가는데 서버와 api 통신이나, 연산과 같은 각 Action이 실행될 때 필요한 로직이 들어갑니다. 그리고 resource폴더에는 언어별로 필요한 학습 데이터와 화면을 구성하는데 필요한 파일들이 들어갑니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
캡슐에서는 사용자에게 보여지는 하나의 화면을 Moment라고 하며 여기에는 Dialog, View 그리고 Follow-Ups이 포함됩니다.
&lt;/div&gt;
&lt;p&gt;참고: &lt;a href=&quot;https://bixbydevelopers.com/dev/docs/dev-guide/design-guides/service&quot;&gt;Designing Your Capsule&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그리고 &lt;strong&gt;capsule.bxb&lt;/strong&gt; 파일을 보시면 아래와 같이 나와있는데요, 캡슐의 기본 설정 값을 입력한다고 생각하시면 됩니다. 저희는 한국어를 기본으로 할 것이기 때문에 &lt;strong&gt;targets&lt;/strong&gt; 값을 &lt;strong&gt;bixby-mobile-ko-KR&lt;/strong&gt; 로 변경합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;capsule {
  id (study.dice)
  version (0.1.0)
  format (3)
  targets {
    target (bixby-mobile-ko-KR)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음에는 Concept과 Actions를 추가하여 모델링을 해보겠습니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 에디터(1406)</title>
   <link href="http://localhost:4000/algorithm/2018/12/18/boj-editor-1406/"/>
   <updated>2018-12-18T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/18/boj-editor-1406</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;이중 링크드 리스트(Double Linked List)&lt;/strong&gt;이용하여 해결할 수 있는 문제입니다. 각 노드를 ‘커서’가 가리키고 있는 위치라고 한다면, 노드 안에 데이터는 ‘커서’ 바로 뒤의 문자입니다. 예를 들어서 문자열 ‘ABC’가 있으면 첫 번째 노드는 맨 앞 ‘커서’이고 가지고 있는 데이터는 ‘A’입니다. 즉, 각 노드는 ‘첫 번째 커서[A]’, ‘두 번째 커서[B]’, ‘세 번째 커서[C]’ 를 의미합니다. 그런데 ‘커서’가 문자열의 맨 뒤에도 위치할 수 있기 때문에 임의의 노드를 하나 더 추가해야 합니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
scanf 함수로 문자를 받으니, 다음 scanf 함수에 개행(\n)이 입력으로 들어갔습니다. 이 문제를 해결하기 위해서 scanf로 문자를 받은 다음에 바로 다음에 getchar() 함수를 사용해서 개행(\n)문자를 입력으로 받았습니다.
&lt;/div&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Node {
	Node* next;
	Node* prev;
	char data;
} nr[600005];
int nidx = 0;
Node* allocNode(char data) {
	Node* nn = &amp;amp;nr[nidx++];
	nn-&amp;gt;data = data;
	return nn;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;이중-링크드-리스트&quot;&gt;이중 링크드 리스트&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Node* head = nullptr;
Node* tail = nullptr;

void add(char data) {
	Node* nn = allocNode(data);

	if (head == nullptr) {
		head = nn;
		tail = nn;
	} else {
		tail-&amp;gt;next = nn;
		nn-&amp;gt;prev = tail;
		tail = nn;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;편집기-기능&quot;&gt;편집기 기능&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Node* pointer = nullptr;
void addAtPointer(char data) {
	Node* nn = allocNode(data);
	
	if (pointer == head) {
		nn-&amp;gt;next = pointer;
		pointer-&amp;gt;prev = nn;

		head = nn;
	} else {
		nn-&amp;gt;next = pointer;
		nn-&amp;gt;prev = pointer-&amp;gt;prev;
		pointer-&amp;gt;prev-&amp;gt;next = nn;
		pointer-&amp;gt;prev = nn;
	}
}
void del() {
	if (pointer == head) {
		return;
	}
	if (pointer-&amp;gt;prev == head) {
		head = pointer;
		pointer-&amp;gt;prev = nullptr;
	} else {
		pointer-&amp;gt;prev-&amp;gt;prev-&amp;gt;next = pointer;
		pointer-&amp;gt;prev = pointer-&amp;gt;prev-&amp;gt;prev;
	}
}

void left() {
	if (pointer != head) {
		pointer = pointer-&amp;gt;prev;
	}
}

void right() {
	if (pointer != tail) {
		pointer = pointer-&amp;gt;next;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main() {

	// 문자열 입력
	scanf(&quot;%s&quot;, str);
	getchar();

	// 문자열 링크드 리스트에 추가
	int strIdx = 0;
	while (str[strIdx] != '\0') {
		add(str[strIdx]);
		strIdx++;
	}

	// 맨 뒤에 커서 추가
	add('-');

	// 포인터 위치 초기화
	pointer = tail;

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);
	getchar();

	while (N--) {
		char key;
		scanf(&quot;%c&quot;, &amp;amp;key);
		getchar();
		if (key == 'P') {
			char nc;
			scanf(&quot;%c&quot;, &amp;amp;nc);
			getchar();
			addAtPointer(nc);
		} else if (key == 'L') {
			left();
		} else if (key == 'D') {
			right();
		} else if (key == 'B') {
			del();
		}
	}

	Node* cur = head;
	while (cur-&amp;gt;data != '-') {
		printf(&quot;%c&quot;, cur-&amp;gt;data);
		cur = cur-&amp;gt;next;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Gettting Started - Overview (2)</title>
   <link href="http://localhost:4000/bixby/2018/12/17/overview_2/"/>
   <updated>2018-12-17T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/17/overview_2</id>
   <content type="html">&lt;p&gt;이번 포스트에서는 우리가 구현하는 &lt;strong&gt;캡슐(Capsule)&lt;/strong&gt;이 플랫폼에서 어떻게 동작하는지 알아보려고 합니다. 내용은 공식 &lt;a href=&quot;https://bixbydevelopers.com/dev/docs/get-started/overview&quot;&gt;Bixby Developer&lt;/a&gt; 페이지를 참고했습니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
빅스비 캡슐(Capsule)은 빅스비 위에서 동작하는 어플리케이션입니다. 스타벅스 캡슐(Startbucks Capsule)이 그중에 하나입니다.
&lt;/div&gt;

&lt;h2 id=&quot;플랫폼과-상호-작용는-캡슐&quot;&gt;플랫폼과 상호 작용는 캡슐&lt;/h2&gt;

&lt;p&gt;개발자는 &lt;strong&gt;‘자연어 학습(Natural Language Traning)’&lt;/strong&gt;, &lt;strong&gt;‘모델링(Concept and Action Models)’&lt;/strong&gt;, &lt;strong&gt;‘함수 작성(API Function)’&lt;/strong&gt; 그리고 사용자에게 보여주는 &lt;strong&gt;화면(Dialog &amp;amp; Layout)&lt;/strong&gt; 을 구현해야 한다고 했는데요, 개발자가 구현한 내용들이 플랫폼에서 동작하는 과정을 알아보려고 합니다. 다음은 사용자 발화가 들어왔을 때 빅스비가 실행되는 Flow입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-16-overview-2/flow-18218708982895970544.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;첫 번째&lt;/strong&gt;로, 사용자가 발화를 하면 빅스비 플랫폼은 개발자가 학습한 데이터를 기반으로 &lt;strong&gt;intent&lt;/strong&gt;로 변환합니다. intent 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Give two values (number of dice and number of sides) with the
// goal of rolling dice
intent {
 goal: example.dice.RollResult
 value: example.dice.NumSides (6)
 value: example.dice.NumDice (2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;두 번째&lt;/strong&gt;로, 변환된 intent를 실행시킬 수 있도록 개발자가 정의한 모델인 Concept과 Action을 참고하여 실행될 프로그램(그래프)를 생성합니다.
&lt;!-- ![image](/assets/2018-12-16-overview/1st-execution-graph-11771877356118750247.png) --&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세 번째&lt;/strong&gt;로, 빅스비가 그래프를 실행하면서 Action에 도달했을 때, 함수(Javascript)가 있다면 같이 실행합니다. 이 함수에는 서버와 통신이나 추가적인 로직들을 넣을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;마지막&lt;/strong&gt;으로 Dialog와 View을 통해 사용자에게 보여줄 화면을 표시합니다.
&lt;!-- ![image](/assets/2018-12-16-overview/layout-result-16107432446437221263.png) --&gt;&lt;/p&gt;

&lt;p&gt;이 모든 과정들은 빅스비 캡슐(Bixby Capsule)에서 동작합니다. 다음 포스트에서는 예제 프로젝트를 개발해보면서 자세하게 알아보도록 하겠습니다. 감사합니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Gettting Started - Overview (1)</title>
   <link href="http://localhost:4000/bixby/2018/12/16/overview_1/"/>
   <updated>2018-12-16T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/16/overview_1</id>
   <content type="html">&lt;p&gt;빅스비 개발을 시작하기 전에 전체적으로 어떻게 동작하는지 간략하게 소개드리려고 합니다. 내용은 공식 &lt;a href=&quot;https://bixbydevelopers.com/dev/docs/get-started/overview&quot;&gt;Bixby Developer&lt;/a&gt; 페이지를 참고했습니다.&lt;/p&gt;

&lt;h2 id=&quot;무엇을-개발해야-하나요&quot;&gt;무엇을 개발해야 하나요&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/bixby/2018/12/13/intro/&quot;&gt;이전 포스팅&lt;/a&gt;에서도 설명 드렸듯이 빅스비는 전통적인 프로그래밍 방식과 다른 개발 방식을 보입니다. 개발자는 빅스비가 사용자의 발화를 이해할 수 있도록 IDE에서 자연어를 학습시켜야 합니다. 또한 빅스비가 &lt;strong&gt;실행 그래프&lt;/strong&gt; 를 구성할 수 있게 &lt;strong&gt;모델링&lt;/strong&gt;을 해주고, 필요하다면 서버와 통신과 같은 추가적인 함수를 작성해야 합니다. 마지막으로 사용자에게 보여줄 Dialog와 Layout을 작성합니다.&lt;/p&gt;

&lt;p&gt;다음은 빅스비가 사용자의 발화를 이해하고 그래프를 구성한 예제입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“&lt;strong&gt;면이 여섯 개&lt;/strong&gt;인 &lt;strong&gt;두 개&lt;/strong&gt;의 주사위를 굴렸을 때 나온 숫자의 총 합을 구해줘”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-16-overview_1/1st-execution-graph-11771877356118750247.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자는 그림과 같이 그래프를 구성하기 위해서 아래의 작업을 해줘야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 발화에서 NumDice(2)와 NumSides(6)를 추출할 수 있도록 &lt;strong&gt;자연어를 학습&lt;/strong&gt;합니다.&lt;/li&gt;
  &lt;li&gt;그래프가 만들어 질 수 있도록 NumDice, NumSides 그리고 RollDice를 &lt;strong&gt;모델링&lt;/strong&gt;을 합니다.&lt;/li&gt;
  &lt;li&gt;RollDice로 입력된 두 값을 사용하여 RollResult를 계산하는 &lt;strong&gt;함수&lt;/strong&gt;를 넣습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 
**모델링(Modeling)**은 **Concept**과 **Action**을 정의하는 작업이라고 생각하시면 됩니다. 우리가 보고 있는 예제에서는 NumDice, NumSides, RollResult가 Concept이고 RollDice가 Action입니다. 나중에 조금 더 자세하게 다루겠습니다. 아래는 공식 홈페이지에 나와있는 Concept과 Action에 대한 설명입니다.
&gt;A **concept** describes any &quot;thing.&quot; It could represent a concrete object, such as coffee, flowers, or an airport.

&gt;An **action** defines an operation that Bixby can perform, directly or indirectly, on behalf of a user. If concepts are nouns, actions are verbs. 
--&gt;

&lt;p&gt;다음은 RollDice 함수입니다. 서버와의 통신이나 추가로 필요한 함수는 Javascript로 작성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// RollDice
// Rolls a dice given a number of sides and a number of dice

// Main entry point
function rollDice(numDice, numSides) {

  var sum = 0;
  var result = [];

  for (var i = 0; i &amp;lt; numDice; i++) {
    var roll = Math.ceil(Math.random() * numSides);
    result.push(roll);
    sum += roll;
  }

  // RollResult
  return {
    sum: sum, // required Sum
    roll: result // required list Roll
  }
}

// Exports
module.exports = {
  function: rollDice
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 RollResult가 사용자에게 보여지도록 &lt;strong&gt;Dialog&lt;/strong&gt;와 &lt;strong&gt;Layout&lt;/strong&gt;을 작성하면 아래처럼 결과를 볼 수 있습니다. 아래 그림에서 빅스비가 얘기하는 부분(‘Here’s what I found’)이 Dialog이고 추가 정보를 보여주는 부분이 Layout 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-16-overview/layout-result-16107432446437221263.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 포스트에서는 설명을 위해서 많은 부분을 생략했는데요, 자연어 학습 및 모델링 하는 부분은 나중에 예제를 프로젝트를 통해서 알아보도록 하겠습니다.
다음 포스트에서는 빅스비 플랫폼이 어떻게 동작하는지 설명드리겠습니다. 감사합니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 조세퍼스 문제(1158)</title>
   <link href="http://localhost:4000/algorithm/2018/12/16/boj-josephus-1158/"/>
   <updated>2018-12-16T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/16/boj-josephus-1158</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;이중 연결 리스트(Double Linked List)&lt;/strong&gt;를 연습하기 위해 풀어본 문제입니다. 문제를 풀기 위해서 &lt;strong&gt;원형 링크드 리스트(Circular Liked List)&lt;/strong&gt;를 구현해야 하는데 이중 연결 리스트를 이용해서 구현했습니다.&lt;/p&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct Node {
	Node* next;
	Node* prev;
	int data;
}narr[5005];

int nidx = 0;
Node* allocNode() {
	return &amp;amp;narr[nidx++];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;원형-링크드-리스트&quot;&gt;원형 링크드 리스트&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Node* head = NULL;
Node* tail = NULL;

void addNode(int data) {
	Node* nn = allocNode();
	nn-&amp;gt;data = data;
	if (head == NULL) {
		head = nn;
		tail = nn;
		nn-&amp;gt;prev = tail;
		nn-&amp;gt;next = head;
	} else {
		head-&amp;gt;prev = nn;
		tail-&amp;gt;next = nn;
		nn-&amp;gt;prev = tail;
		nn-&amp;gt;next = head;
		tail = nn;
	}
}

int delNode(int idx) {
	Node* cn = head;
	if (head == NULL) return 0;
	while (--idx) {
		cn = cn-&amp;gt;next;
	}
	head = cn-&amp;gt;next;

	cn-&amp;gt;prev-&amp;gt;next = cn-&amp;gt;next;
	cn-&amp;gt;next-&amp;gt;prev = cn-&amp;gt;prev;
	return cn-&amp;gt;data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
	int N, M;
	scanf(&quot;%d %d&quot;, &amp;amp;N, &amp;amp;M);

	for (int i = 1; i &amp;lt;= N; i++) {
		addNode(i);
	}

	printf(&quot;&amp;lt;&quot;);
	for (int i = 1; i &amp;lt; N; i++) {
		printf(&quot;%d, &quot;, delNode(M));
	}
	printf(&quot;%d&quot;, delNode(M));
	printf(&quot;&amp;gt;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 카드 정렬(1715)</title>
   <link href="http://localhost:4000/algorithm/2018/12/15/boj-card-merge-1715/"/>
   <updated>2018-12-15T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/15/boj-card-merge-1715</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;최대 힙(MaxHeap)&lt;/strong&gt;을 연습하기 위해 풀어본 문제입니다. 문제를 풀기 위해서는 가지고 있는 카드 묶음 중 가장 작은 두 묶음을 찾아서 더해주어야 했기 때문에 &lt;strong&gt;최소 힙(MinHeap)&lt;/strong&gt;을 사용했습니다. 가장 작은 묶음 두 개를 꺼내서 더해준 후 다시 최소 힙에 넣어줍니다. 힙 안에 한 개만 남을 때까지 반복합니다. 힙만 구현하면 메인 함수는 매우 간단합니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
최대 힙에서 최소 힙으로 변경할 때 부등호만 변경해 주었더니 정상적으로 동작하지 않았습니다. 최대 힙에서는 모든 노드를 0으로 초기화 했었는데요, 최소 힙에서는 값이 마지막 자리를 찾아가는 과정에서 문제가 발생했습니다. 이를 해결하기 위해 마지막 노드의 Index 사용하여 비교할 자식 노드가 있는지 확인했습니다.
&lt;/div&gt;

&lt;h2 id=&quot;최소-힙minheap&quot;&gt;최소 힙(MinHeap)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 초기화
int minHeap[200005];
int lastIdx = 0;

// 자식 노드 Index 
int getLeftChild(int idx) {
	return idx * 2;
}

int getRightChild(int idx) {
	return idx * 2 + 1;
}

// 부모 노드 Index 
int getParent(int idx) {
	return idx / 2;
}

// 교환하는 함수
void swap(int idx1, int idx2, int* arr) {
	int tmp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = tmp;
}

// dequeue 함수
int dequeue() {

	if (lastIdx == 0) return -1;

	int maxVal = minHeap[1];
	minHeap[1] = minHeap[lastIdx];
	minHeap[lastIdx] = 0;
	lastIdx--;

	int curIdx = 1;
	while (true) {
		int left = getLeftChild(curIdx);
		int right = getRightChild(curIdx);

		int curVal = minHeap[curIdx];

		int leftVal = minHeap[left];
		int rightVal = minHeap[right];

		int nextIdx;
		int nextVal;

		// 자식 노드가 없는 경우
		if (lastIdx &amp;lt; left) {
			break;

		// 왼쪽 자식 노드만 있는 경우 
		} else if (lastIdx == left) {
			nextIdx = left;
			nextVal = minHeap[nextIdx];

		// 둘 다 있는 경우 비교
		} else if (lastIdx &amp;gt;= right) {
			nextIdx = leftVal &amp;lt; rightVal ? left : right;
			nextVal = minHeap[nextIdx];
		}

		if (curVal &amp;gt; nextVal) {
			swap(curIdx, nextIdx, minHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}

	return maxVal;
}

// enqueue 함수
void enqueue(int val) {
	lastIdx++;
	minHeap[lastIdx] = val;

	int curIdx = lastIdx;
	while (true) {
		if (curIdx == 1) break;

		int nextIdx = getParent(curIdx);

		int curVal = minHeap[curIdx];
		int nextVal = minHeap[nextIdx];

		if (curVal &amp;lt; nextVal) {
			swap(curIdx, nextIdx, minHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	int ans = 0;

	// enqueue
	while (N--) {
		int val;
		scanf(&quot;%d&quot;, &amp;amp;val);
		enqueue(val);
	}

	// 비교 횟수 계산
	while (lastIdx &amp;gt; 1) {
		int val1 = dequeue();
		int val2 = dequeue();
		
		ans += (val1 + val2);

		enqueue(val1 + val2);
	}

	printf(&quot;%d&quot;, ans);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>포스팅을 시작하면서</title>
   <link href="http://localhost:4000/bixby/2018/12/13/intro/"/>
   <updated>2018-12-13T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/13/intro</id>
   <content type="html">&lt;h2 id=&quot;포스팅을-시작하면서&quot;&gt;포스팅을 시작하면서&lt;/h2&gt;

&lt;p&gt;안녕하세요. 블로그를 시작하면서 어떤 내용을 정리하면 좋을지 고민해봤습니다. 그러다가 현재 개발하고 있으면서, 동시에 자료가 없어서 고생중인 빅스비 개발에 대해 정리하면 좋겠다는 생각을 했습니다. 공부도 하면서 (개발하는 사람은 적더라도)공유하는 공간을 만들면 의미가 있을 것이라고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;인공지능--딥러닝&quot;&gt;[인공지능 == 딥러닝]?&lt;/h2&gt;

&lt;p&gt;개인적으로 딥러닝에 관심을 가지며 조금씩 공부하고 있지만 딥러닝이 인공지능의 전부는 아니라고 생각합니다. 이미 많은 사람들이 
&lt;a href=&quot;https://translate.google.co.kr/&quot;&gt;번역&lt;/a&gt;, 
화질 개선, 얼굴 인식 
등 (매우 놀라운)딥러닝 기술을 다양한 곳에서 접하고 있지만 우리가 어릴때부터 상상해왔던 인공지능과는 조금 달라 보입니다. 우리가 상상했던 인공지능은 &lt;a href=&quot;https://www.youtube.com/watch?v=LikxFZZO2sk&quot;&gt;Parkour Atlas&lt;/a&gt;와 같은 &lt;strong&gt;로봇&lt;/strong&gt;이나 &lt;a href=&quot;https://assistant.google.com/&quot;&gt;Google Assistance&lt;/a&gt;, &lt;a href=&quot;https://developer.amazon.com/alexa&quot;&gt;Alexa&lt;/a&gt; 혹은 &lt;a href=&quot;https://kakao.ai/&quot;&gt;카카오 미니&lt;/a&gt;와 같이 사람과 대화를 주고 받는 &lt;strong&gt;음성 인식 비서&lt;/strong&gt;에 더 가깝지 않았나요? 저는 딥러닝과 마찬가지로 사람과 상호작용하는 서비스도 매우 중요하다고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-13-intro/robot.jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인공지능을-modeling&quot;&gt;인공지능을 Modeling&lt;/h2&gt;

&lt;p&gt;일 년 전 쯤에 회사 동료 한분과 함께 서울대 연구소에서 진행한 ‘NLP 딥러닝’ 세미나를 다녀온 적이 있었는데요, 그 당시 인공지능이라고 말하는 챗봇은 [&lt;em&gt;switch case&lt;/em&gt;] 가 90% 이상이라는 얘기를 들었습니다. 하지만, 요즘 챗봇 Builder 와 마찬가지로 &lt;strong&gt;빅스비도 독립적인 개발 방식&lt;/strong&gt;을 보입니다. 모든 실행 Flow을 개발자가 직접적으로 프로그래밍하여 제어하는 것이 아닌, 개발자는 일부 코드와 &lt;strong&gt;Modeling&lt;/strong&gt;을 제공하면 빅스비가 내부 규칙에 따라서 Flow를 구성해 실행합니다. 사실 이 전통적인 프로그래밍과 다른 방식 때문에 개발하다보면 답답하기도 하고 화나기도 하고 심지어 전체 구조를 뒤집을 때도 있습니다. 하지만 조금씩 적응(이해)하다보면 매력을 느낄 수 있을 것이라고 생각합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Developing for Bixby is different than traditional software development because you’re not writing the program; the Artificial Intelligence (AI) is. You perform modeling, which is how you teach Bixby about the domain you’re implementing. Using your models, and those of other developers, Bixby constructs a program that satisfies the user’s specific request in milliseconds the moment the request is made. As a developer, your job is to teach Bixby how to write these programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;앞으로&quot;&gt;앞으로&lt;/h2&gt;
&lt;p&gt;많이 공부하고, 도움을 드릴 수 있는 기회가 되었으면 좋겠습니다. 감사합니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 최대 힙(11279)</title>
   <link href="http://localhost:4000/algorithm/2018/12/11/boj-max-heap-11279/"/>
   <updated>2018-12-11T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/11/boj-max-heap-11279</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;배열&lt;/strong&gt;을 사용해서 간단하게 구현한 &lt;strong&gt;최대 힙(MaxHeap)&lt;/strong&gt;입니다. 코드의 길이를 줄이기 보다는 가독성을 높이는 방향으로 작성했습니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
힙이 가득찬 상태에서 자식 노드의 위치를 가져올 때 배열의 Index를 넘어서 런타임 에러가 발생했습니다. 따로 로직을 추가해서 처리해도 되지만 메모리가 충분하기 때문에 배열의 크기를 (최대 힙 크기 * 2 + 1) 이상으로 잡았습니다.
&lt;/div&gt;

&lt;h2 id=&quot;최대-힙&quot;&gt;최대 힙&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 최대힙 초기화
int maxHeap[200005];
int lastIdx = 0;

// 자식 노드 Index 
int getLeftChild(int idx) {
	return idx * 2;
}

int getRightChild(int idx) {
	return idx * 2 + 1;
}

// 부모 노드 Index 
int getParent(int idx) {
	return idx / 2;
}

// 교환하는 함수
void swap(int idx1, int idx2, int* arr) {
	int tmp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = tmp;
}

// dequeue 함수
int dequeue() {
	
	if (lastIdx == 0) return 0;

	int head = maxHeap[1];
	maxHeap[1] = maxHeap[lastIdx];
	maxHeap[lastIdx] = 0;
	lastIdx--;

	int curIdx = 1;
	while (true) {
		int rIdx = getRightChild(curIdx);
		int lIdx = getLeftChild(curIdx);

		int curVal = maxHeap[curIdx];
		int rVal = maxHeap[rIdx];
		int lVal = maxHeap[lIdx];
		
		int nextIdx = rVal &amp;gt; lVal ? rIdx : lIdx;
		int nextVal = maxHeap[nextIdx];
		if (curVal &amp;lt; nextVal) {
			swap(curIdx, nextIdx, maxHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}

	return head;
}

// enqueue 함수
void enqueue(int val) {
	lastIdx++;
	maxHeap[lastIdx] = val;

	int curIdx = lastIdx;
	while (true) {
		if (curIdx == 1) break;

		int pIdx = getParent(curIdx);
		
		int curVal = maxHeap[curIdx];
		int pVal = maxHeap[pIdx];

		int nextIdx = pIdx;
		int nextVal = maxHeap[nextIdx];
		if (curVal &amp;gt; nextVal) {
			swap(curIdx, nextIdx, maxHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
	
	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	while (N--) {
		int x;
		scanf(&quot;%d&quot;, &amp;amp;x);

		if (x &amp;gt; 0) {
			enqueue(x);
		} else if (x == 0) {
			int val = dequeue();
			printf(&quot;%d\n&quot;, val);
		}
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 스택 수열(1874)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-stack-series-1874/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-stack-series-1874</id>
   <content type="html">&lt;p&gt;구조체 배열이 아닌 단순 &lt;strong&gt;배열&lt;/strong&gt;을 사용해서 구현한 스택 수열 알고리즘 코드입니다.&lt;/p&gt;

&lt;h2 id=&quot;배열과-헤드위치-선언&quot;&gt;배열과 헤드위치 선언&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int stack[100005];
int head = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int stack[100005];
int head = 0;

int main() {

	int n;
	scanf(&quot;%d&quot;, &amp;amp;n);

	int inc = 1;

	int outputIdx = 0;
	char output[500005];
	bool isFailed = false;

	while(n--) {

		int number;
		scanf(&quot;%d&quot;, &amp;amp;number);

		// 수열이 형성되지 못하는 경우 체크
		if (head &amp;lt; 0 || number &amp;lt; stack[head]) {
			isFailed = true;
			break;;
		}

		// 출력(POP)되어야 할 숫자(number)가 스택에 들어갈 때까지 PUSH
		while (stack[head] &amp;lt; number) {
			output[outputIdx++] = '+';
			stack[++head] = inc;
			inc++;
		}
		
		// 숫자(number)를 출력(POP)
		while (stack[head] &amp;gt;= number) {
			output[outputIdx++] = '-';
			head--;
		}

	}

	if (isFailed) {
		printf(&quot;NO\n&quot;);
	} else {
		for (int i = 0; i &amp;lt; outputIdx; i++ ) {
			printf(&quot;%c\n&quot;, output[i]);
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 스택(10828)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-stack-10828/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-stack-10828</id>
   <content type="html">&lt;p&gt;간단한 &lt;strong&gt;링크드 리스트&lt;/strong&gt;를 이용해서 구현한 &lt;strong&gt;스택&lt;/strong&gt;입니다. 배열을 사용해서 더 간단하게도 구현 가능하지만 &lt;strong&gt;구조체 배열&lt;/strong&gt;을 연습하고자 링크드 리스트를 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 정적이지만 동적할당처럼 사용하는 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 아래와 같이 사용할 수 있습니다.
Node* node = allocNode();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;cstring&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

// 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 메인 함수
int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);


	Node* head = '\0';
	char order[10];
	int count = 0;
	while (N--) {
		scanf(&quot;%s&quot;, order);

		if (order[1] == 'u') {
			int data;
			scanf(&quot;%d&quot;, &amp;amp;data);
			Node* node = allocNode();
			node-&amp;gt;data = data;

			if (count == 0) {
				head = node;
			} else {
				node-&amp;gt;next = head;
				head = node;
			}
			count++;
		} else if (order[0] == 'p') {
			if (head == '\0') {
				printf(&quot;%d\n&quot;, -1);
			} else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
				head = head-&amp;gt;next;
				count--;
			}
		} else if (order[0] == 's') {
			printf(&quot;%d\n&quot;, count);
		} else if (order[0] == 'e') {
			if (count == 0) {
				printf(&quot;%d\n&quot;, 1);
			} else {
				printf(&quot;%d\n&quot;, 0);
			}
		} else if (order[0] == 't') {
			if (count == 0) {
				printf(&quot;%d\n&quot;, -1);
			} else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
			}
		}
	};

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 큐(10845)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-queue-10845/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-queue-10845</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;../backjoon-stack-10828/&quot;&gt;스택(10828)&lt;/a&gt;과 마찬가지로 간단한 &lt;strong&gt;링크드 리스트&lt;/strong&gt;를 이용해서 구현한 &lt;strong&gt;큐&lt;/strong&gt;입니다. 배열을 사용해서 더 간단하게도 구현 가능하지만 &lt;strong&gt;구조체 배열&lt;/strong&gt;을 연습하고자 링크드 리스트를 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 정적이지만 동적할당처럼 사용하는 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 아래와 같이 사용할 수 있습니다.
Node* node = allocNode();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

// 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeidx = 0;
Node nodearray[10000];
Node* allocNode() {
	return &amp;amp;nodearray[nodeidx++];
};

// 메인 함수
int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	Node* head = '\0';
	Node* tail = '\0';

	char order[6];
	int count = 0;
	while (N--) {
		scanf(&quot;%s&quot;, order);

		// 새로운 노드 생성해서 큐에 PUSH
		if (order[1] == 'u') {
			int data;
			scanf(&quot;%d&quot;, &amp;amp;data);
			Node* node = allocNode();
			node-&amp;gt;data = data;
			if (count == 0) {
				head = node;
				tail = node;
			} else {
				tail-&amp;gt;next = node;
				tail = node;
			}
			count++;

		// 상위 노드(head) POP
		} else if (order[0] == 'p') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
				head = head-&amp;gt;next;
				count--;
			}

		// 큐에 있는 노드 갯수 출력
		} else if (order[0] == 's') {
			printf(&quot;%d\n&quot;, count);

		// 큐가 비어 있는지 확인
		} else if (order[0] == 'e') {
			if (count == 0) printf(&quot;1\n&quot;);
			else printf(&quot;0\n&quot;);

		// 상위 노드(head) 값 출력
		} else if (order[0] == 'f') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
			}

		// 마지막 노드(tail) 값 출력
		} else if (order[0] == 'b') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, tail-&amp;gt;data);
			}
		}
	};
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Example content</title>
   <link href="http://localhost:4000/daily/2018/12/01/example-content/"/>
   <updated>2018-12-01T00:00:00+09:00</updated>
   <id>http://localhost:4000/daily/2018/12/01/example-content</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Howdy! This is an example blog post that shows several types of HTML content supported in this theme.
&lt;/div&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis &lt;a href=&quot;#&quot;&gt;dis parturient montes&lt;/a&gt;, nascetur ridiculus mus. &lt;em&gt;Aenean eu leo quam.&lt;/em&gt; Pellentesque ornare sem lacinia quam venenatis vestibulum. Sed posuere consectetur est at lobortis. Cras mattis consectetur purus sit amet fermentum.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Curabitur blandit tempus porttitor. Nullam quis risus eget urna mollis ornare vel eu leo. Nullam id dolor id nibh ultricies vehicula ut id elit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Etiam porta &lt;strong&gt;sem malesuada magna&lt;/strong&gt; mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p&gt;

&lt;h2 id=&quot;inline-html-elements&quot;&gt;Inline HTML elements&lt;/h2&gt;

&lt;p&gt;HTML defines a long list of available inline tags, a complete list of which can be found on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&quot;&gt;Mozilla Developer Network&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;To bold text&lt;/strong&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;To italicize text&lt;/em&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Abbreviations, like &lt;abbr title=&quot;HyperText Markup Langage&quot;&gt;HTML&lt;/abbr&gt; should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, with an optional &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; attribute for the full phrase.&lt;/li&gt;
  &lt;li&gt;Citations, like &lt;cite&gt;— Mark otto&lt;/cite&gt;, should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Deleted&lt;/del&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; and &lt;ins&gt;inserted&lt;/ins&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Superscript &lt;sup&gt;text&lt;/sup&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sup&amp;gt;&lt;/code&gt; and subscript &lt;sub&gt;text&lt;/sub&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of these elements are styled by browsers with few modifications on our part.&lt;/p&gt;

&lt;h2 id=&quot;heading&quot;&gt;Heading&lt;/h2&gt;

&lt;p&gt;Vivamus sagittis lacus vel augue rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Morbi leo risus, porta ac consectetur ac, vestibulum at eros.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis &lt;code class=&quot;highlighter-rouge&quot;&gt;code element&lt;/code&gt; montes, nascetur ridiculus mus.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Example can be run directly in your JavaScript console

// Create a function that takes two arguments and returns the sum of those arguments
var adder = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);

// Call the function
adder(2, 6);
// &amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa.&lt;/p&gt;

&lt;h3 id=&quot;lists&quot;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur et.&lt;/li&gt;
  &lt;li&gt;Donec id elit non mi porta gravida at eget metus.&lt;/li&gt;
  &lt;li&gt;Nulla vitae elit libero, a pharetra augue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Donec ullamcorper nulla non metus auctor fringilla. Nulla vitae elit libero, a pharetra augue.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vestibulum id ligula porta felis euismod semper.&lt;/li&gt;
  &lt;li&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/li&gt;
  &lt;li&gt;Maecenas sed diam eget risus varius blandit sit amet non magna.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cras mattis consectetur purus sit amet fermentum. Sed posuere consectetur est at lobortis.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;HyperText Markup Language (HTML)&lt;/dt&gt;
  &lt;dd&gt;The language used to describe and define the content of a Web page&lt;/dd&gt;

  &lt;dt&gt;Cascading Style Sheets (CSS)&lt;/dt&gt;
  &lt;dd&gt;Used to describe the appearance of Web content&lt;/dd&gt;

  &lt;dt&gt;JavaScript (JS)&lt;/dt&gt;
  &lt;dd&gt;The programming language used to build advanced Web sites and applications&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Upvotes&lt;/th&gt;
      &lt;th&gt;Downvotes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;Totals&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alice&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bob&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Charlie&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Nullam id dolor id nibh ultricies vehicula ut id elit. Sed posuere consectetur est at lobortis. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/poole/poole/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
