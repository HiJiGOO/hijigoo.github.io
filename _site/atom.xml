<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>안녕지구</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2018-12-16T02:24:24+09:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>안녕지구</name>
   <email></email>
 </author>

 
 <entry>
   <title>Gettting Started - Overview (1)</title>
   <link href="http://localhost:4000/bixby/2018/12/15/overview/"/>
   <updated>2018-12-15T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/15/overview</id>
   <content type="html">&lt;p&gt;빅스비 개발을 시작하기 전에 전체적으로 어떻게 동작하는지 간략하게 소개드리려고 합니다. 내용은 공식 &lt;a href=&quot;https://bixbydevelopers.com/dev/docs/get-started/overview&quot;&gt;Bixby Developer&lt;/a&gt; 페이지를 참고했습니다.&lt;/p&gt;

&lt;h2 id=&quot;무엇을-개발해야-하나요&quot;&gt;무엇을 개발해야 하나요&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/bixby/2018/12/13/intro/&quot;&gt;이전 포스팅&lt;/a&gt;에서도 설명 드렸듯이 빅스비는 전통적인 프로그래밍 방식과 다른 개발 방식을 보입니다. 개발자는 빅스비가 사용자의 발화를 이해할 수 있도록 IDE에서 자연어를 학습시켜야 합니다. 또한 빅스비가 &lt;strong&gt;실행 그래프&lt;/strong&gt; 를 구성할 수 있게 &lt;strong&gt;모델링&lt;/strong&gt;을 해주고, 필요하다면 Backend와 통신과 같은 추가적인 로직을 작성해야 합니다. 마지막으로 사용자에게 보여줄 Layout을 작성합니다.&lt;/p&gt;

&lt;p&gt;다음은 빅스비가 사용자의 발화를 이해하고 그래프를 구성한 예제입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“&lt;strong&gt;면이 여섯 개&lt;/strong&gt;인 &lt;strong&gt;두 개&lt;/strong&gt;의 주사위를 굴렸을 때 나온 숫자의 총 합을 구해줘”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-16-overview/1st-execution-graph-11771877356118750247.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자는 그림과 같이 그래프를 구성하기 위해서 아래의 작업을 해줘야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 발화에서 NumDice(2)와 NumSides(6)를 추출할 수 있도록 &lt;strong&gt;자연어를 학습&lt;/strong&gt;합니다.&lt;/li&gt;
  &lt;li&gt;NumDice와 NumSides가 추출 되고 RollDice의 입력으로 들아갈 수 있도록 &lt;strong&gt;모델링&lt;/strong&gt;을 합니다.&lt;/li&gt;
  &lt;li&gt;RollDice로 입력된 두 값을 사용하여 RollResult를 계산하는 &lt;strong&gt;로직&lt;/strong&gt;을 넣습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음은 RollDice 로직입니다. 서버와의 통신이나 추가로 필요한 로직은 Javascript로 작성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// RollDice
// Rolls a dice given a number of sides and a number of dice

// Main entry point
function rollDice(numDice, numSides) {

  var sum = 0;
  var result = [];

  for (var i = 0; i &amp;lt; numDice; i++) {
    var roll = Math.ceil(Math.random() * numSides);
    result.push(roll);
    sum += roll;
  }

  // RollResult
  return {
    sum: sum, // required Sum
    roll: result // required list Roll
  }
}

// Exports
module.exports = {
  function: rollDice
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 RollResult가 사용자에게 보여지도록 Layout을 작성하면 아래처럼 결과를 볼 수 있습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-16-overview/layout-result-16107432446437221263.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 포스트에서는 이해를 위해서 많은 부분을 생략했는데요, 자연어 학습 및 모델링 하는 부분은 나중에 예제를 프로젝트를 통해서 알아보도록 하겠습니다.
다음 포스트에서는 빅스비 플랫폼이 어떻게 동작하는지 설명드리겠습니다. 감사합니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 카드 정렬(1715)</title>
   <link href="http://localhost:4000/algorithm/2018/12/15/boj-card-merge-1715/"/>
   <updated>2018-12-15T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/15/boj-card-merge-1715</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;최대 힙(MaxHeap)&lt;/strong&gt;을 연습하기 위해 풀어본 문제입니다. 문제를 풀기 위해서는 가지고 있는 카드 묶음 중 가장 작은 두 묶음을 찾아서 더해주어야 했기 때문에 &lt;strong&gt;최소 힙(MinHeap)&lt;/strong&gt;을 사용했습니다. 가장 작은 묶음 두 개를 꺼내서 더해준 후 다시 최소 힙에 넣어줍니다. 힙 안에 한 개만 남을 때까지 반복합니다. 힙만 구현하면 메인 함수는 매우 간단합니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
최대 힙에서 최소 힙으로 변경할 때 부등호만 변경해 주었더니 정상적으로 동작하지 않았습니다. 최대 힙에서는 모든 노드를 0으로 초기화 했었는데요, 최소 힙에서는 값이 마지막 자리를 찾아가는 과정에서 문제가 발생했습니다. 이를 해결하기 위해 마지막 노드의 Index 사용하여 비교할 자식 노드가 있는지 확인했습니다.
&lt;/div&gt;

&lt;h2 id=&quot;최소-힙minheap&quot;&gt;최소 힙(MinHeap)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 초기화
int minHeap[200005];
int lastIdx = 0;

// 자식 노드 Index 
int getLeftChild(int idx) {
	return idx * 2;
}

int getRightChild(int idx) {
	return idx * 2 + 1;
}

// 부모 노드 Index 
int getParent(int idx) {
	return idx / 2;
}

// 교환하는 함수
void swap(int idx1, int idx2, int* arr) {
	int tmp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = tmp;
}

// dequeue 함수
int dequeue() {

	if (lastIdx == 0) return -1;

	int maxVal = minHeap[1];
	minHeap[1] = minHeap[lastIdx];
	minHeap[lastIdx] = 0;
	lastIdx--;

	int curIdx = 1;
	while (true) {
		int left = getLeftChild(curIdx);
		int right = getRightChild(curIdx);

		int curVal = minHeap[curIdx];

		int leftVal = minHeap[left];
		int rightVal = minHeap[right];

		int nextIdx;
		int nextVal;

		// 자식 노드가 없는 경우
		if (lastIdx &amp;lt; left) {
			break;

		// 왼쪽 자식 노드만 있는 경우 
		} else if (lastIdx == left) {
			nextIdx = left;
			nextVal = minHeap[nextIdx];

		// 둘 다 있는 경우 비교
		} else if (lastIdx &amp;gt;= right) {
			nextIdx = leftVal &amp;lt; rightVal ? left : right;
			nextVal = minHeap[nextIdx];
		}

		if (curVal &amp;gt; nextVal) {
			swap(curIdx, nextIdx, minHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}

	return maxVal;
}

// enqueue 함수
void enqueue(int val) {
	lastIdx++;
	minHeap[lastIdx] = val;

	int curIdx = lastIdx;
	while (true) {
		if (curIdx == 1) break;

		int nextIdx = getParent(curIdx);

		int curVal = minHeap[curIdx];
		int nextVal = minHeap[nextIdx];

		if (curVal &amp;lt; nextVal) {
			swap(curIdx, nextIdx, minHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	int ans = 0;

	// enqueue
	while (N--) {
		int val;
		scanf(&quot;%d&quot;, &amp;amp;val);
		enqueue(val);
	}

	// 비교 횟수 계산
	while (lastIdx &amp;gt; 1) {
		int val1 = dequeue();
		int val2 = dequeue();
		
		ans += (val1 + val2);

		enqueue(val1 + val2);
	}

	printf(&quot;%d&quot;, ans);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>포스팅을 시작하면서</title>
   <link href="http://localhost:4000/bixby/2018/12/13/intro/"/>
   <updated>2018-12-13T00:00:00+09:00</updated>
   <id>http://localhost:4000/bixby/2018/12/13/intro</id>
   <content type="html">&lt;h2 id=&quot;포스팅을-시작하면서&quot;&gt;포스팅을 시작하면서&lt;/h2&gt;

&lt;p&gt;안녕하세요. 블로그를 시작하면서 어떤 내용을 정리하면 좋을지 고민해봤습니다. 그러다가 현재 개발하고 있으면서, 동시에 자료가 없어서 고생중인 ‘빅스비 캡슐’개발에 대해 정리하면 좋겠다는 생각을 했습니다. 공부도 하면서 (개발하는 사람은 적더라도)공유하는 공간을 만들면 의미가 있을 것이라고 생각합니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
빅스비 캡슐(Capsule)은 빅스비 위에서 동작하는 어플리케이션입니다.
&lt;/div&gt;

&lt;h2 id=&quot;인공지능--딥러닝&quot;&gt;[인공지능 == 딥러닝]?&lt;/h2&gt;

&lt;p&gt;개인적으로 딥러닝에 관심을 가지며 조금씩 공부하고 있지만 딥러닝이 인공지능의 전부는 아니라고 생각합니다. 이미 많은 사람들이 
&lt;a href=&quot;https://translate.google.co.kr/&quot;&gt;번역&lt;/a&gt;, 
화질 개선, 얼굴 인식 
등 (매우 놀라운)딥러닝 기술을 다양한 곳에서 접하고 있지만 우리가 어릴때부터 상상해왔던 인공지능과는 조금 달라 보입니다. 우리가 상상했던 인공지능은 &lt;a href=&quot;https://www.youtube.com/watch?v=LikxFZZO2sk&quot;&gt;Parkour Atlas&lt;/a&gt;와 같은 &lt;strong&gt;로봇&lt;/strong&gt;이나 &lt;a href=&quot;https://assistant.google.com/&quot;&gt;Google Assistance&lt;/a&gt;, &lt;a href=&quot;https://developer.amazon.com/alexa&quot;&gt;Alexa&lt;/a&gt; 혹은 &lt;a href=&quot;https://kakao.ai/&quot;&gt;카카오 미니&lt;/a&gt;와 같이 사람과 대화를 주고 받는 &lt;strong&gt;음성 인식 비서&lt;/strong&gt;에 더 가깝지 않았나요? 저는 딥러닝과 마찬가지로 사람과 상호작용하는 서비스도 매우 중요하다고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-12-13-intro/robot.jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인공지능을-modeling&quot;&gt;인공지능을 Modeling&lt;/h2&gt;

&lt;p&gt;일 년 전 쯤에 회사 동료 한분과 함께 서울대 연구소에서 진행한 ‘NLP 딥러닝’ 세미나를 다녀온 적이 있었는데요, 그 당시 인공지능이라고 말하는 챗봇은 [&lt;em&gt;switch case&lt;/em&gt;] 가 90% 이상이라는 얘기를 들었습니다. 하지만, 요즘 챗봇 Builder 와 마찬가지로 &lt;strong&gt;빅스비도 독립적인 개발 방식&lt;/strong&gt;을 보입니다. 모든 실행 Flow을 개발자가 직접적으로 프로그래밍하여 제어하는 것이 아닌, 개발자는 일부 코드와 &lt;strong&gt;Modeling&lt;/strong&gt;을 제공하면 빅스비가 내부 규칙에 따라서 Flow를 구성해 실행합니다. 사실 이 전통적인 프로그래밍과 다른 방식 때문에 개발하다보면 답답하기도 하고 화나기도 하고 심지어 전체 구조를 뒤집을 때도 있습니다. 하지만 조금씩 적응(이해)하다보면 매력을 느낄 수 있을 것이라고 생각합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Developing for Bixby is different than traditional software development because you’re not writing the program; the Artificial Intelligence (AI) is. You perform modeling, which is how you teach Bixby about the domain you’re implementing. Using your models, and those of other developers, Bixby constructs a program that satisfies the user’s specific request in milliseconds the moment the request is made. As a developer, your job is to teach Bixby how to write these programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;앞으로&quot;&gt;앞으로&lt;/h2&gt;
&lt;p&gt;많이 공부하고, 도움을 드릴 수 있는 기회가 되었으면 좋겠습니다. 감사합니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 최대 힙(11279)</title>
   <link href="http://localhost:4000/algorithm/2018/12/11/boj-max-heap-11279/"/>
   <updated>2018-12-11T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/11/boj-max-heap-11279</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;배열&lt;/strong&gt;을 사용해서 간단하게 구현한 &lt;strong&gt;최대 힙(MaxHeap)&lt;/strong&gt;입니다. 코드의 길이를 줄이기 보다는 가독성을 높이는 방향으로 작성했습니다.&lt;/p&gt;

&lt;div class=&quot;message&quot;&gt;
힙이 가득찬 상태에서 자식 노드의 위치를 가져올 때 배열의 Index를 넘어서 런타임 에러가 발생했습니다. 따로 로직을 추가해서 처리해도 되지만 메모리가 충분하기 때문에 배열의 크기를 (최대 힙 크기 * 2 + 1) 이상으로 잡았습니다.
&lt;/div&gt;

&lt;h2 id=&quot;최대-힙&quot;&gt;최대 힙&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 최대힙 초기화
int maxHeap[200005];
int lastIdx = 0;

// 자식 노드 Index 
int getLeftChild(int idx) {
	return idx * 2;
}

int getRightChild(int idx) {
	return idx * 2 + 1;
}

// 부모 노드 Index 
int getParent(int idx) {
	return idx / 2;
}

// 교환하는 함수
void swap(int idx1, int idx2, int* arr) {
	int tmp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = tmp;
}

// dequeue 함수
int dequeue() {
	
	if (lastIdx == 0) return 0;

	int head = maxHeap[1];
	maxHeap[1] = maxHeap[lastIdx];
	maxHeap[lastIdx] = 0;
	lastIdx--;

	int curIdx = 1;
	while (true) {
		int rIdx = getRightChild(curIdx);
		int lIdx = getLeftChild(curIdx);

		int curVal = maxHeap[curIdx];
		int rVal = maxHeap[rIdx];
		int lVal = maxHeap[lIdx];
		
		int nextIdx = rVal &amp;gt; lVal ? rIdx : lIdx;
		int nextVal = maxHeap[nextIdx];
		if (curVal &amp;lt; nextVal) {
			swap(curIdx, nextIdx, maxHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}

	return head;
}

// enqueue 함수
void enqueue(int val) {
	lastIdx++;
	maxHeap[lastIdx] = val;

	int curIdx = lastIdx;
	while (true) {
		if (curIdx == 1) break;

		int pIdx = getParent(curIdx);
		
		int curVal = maxHeap[curIdx];
		int pVal = maxHeap[pIdx];

		int nextIdx = pIdx;
		int nextVal = maxHeap[nextIdx];
		if (curVal &amp;gt; nextVal) {
			swap(curIdx, nextIdx, maxHeap);
			curIdx = nextIdx;
		} else {
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메인-함수&quot;&gt;메인 함수&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
	
	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	while (N--) {
		int x;
		scanf(&quot;%d&quot;, &amp;amp;x);

		if (x &amp;gt; 0) {
			enqueue(x);
		} else if (x == 0) {
			int val = dequeue();
			printf(&quot;%d\n&quot;, val);
		}
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 스택 수열(1874)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-stack-series-1874/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-stack-series-1874</id>
   <content type="html">&lt;p&gt;구조체 배열이 아닌 단순 &lt;strong&gt;배열&lt;/strong&gt;을 사용해서 구현한 스택 수열 알고리즘 코드입니다.&lt;/p&gt;

&lt;h2 id=&quot;배열과-헤드위치-선언&quot;&gt;배열과 헤드위치 선언&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int stack[100005];
int head = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int stack[100005];
int head = 0;

int main() {

	int n;
	scanf(&quot;%d&quot;, &amp;amp;n);

	int inc = 1;

	int outputIdx = 0;
	char output[500005];
	bool isFailed = false;

	while(n--) {

		int number;
		scanf(&quot;%d&quot;, &amp;amp;number);

		// 수열이 형성되지 못하는 경우 체크
		if (head &amp;lt; 0 || number &amp;lt; stack[head]) {
			isFailed = true;
			break;;
		}

		// 출력(POP)되어야 할 숫자(number)가 스택에 들어갈 때까지 PUSH
		while (stack[head] &amp;lt; number) {
			output[outputIdx++] = '+';
			stack[++head] = inc;
			inc++;
		}
		
		// 숫자(number)를 출력(POP)
		while (stack[head] &amp;gt;= number) {
			output[outputIdx++] = '-';
			head--;
		}

	}

	if (isFailed) {
		printf(&quot;NO\n&quot;);
	} else {
		for (int i = 0; i &amp;lt; outputIdx; i++ ) {
			printf(&quot;%c\n&quot;, output[i]);
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 스택(10828)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-stack-10828/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-stack-10828</id>
   <content type="html">&lt;p&gt;간단한 &lt;strong&gt;링크드 리스트&lt;/strong&gt;를 이용해서 구현한 &lt;strong&gt;스택&lt;/strong&gt;입니다. 배열을 사용해서 더 간단하게도 구현 가능하지만 &lt;strong&gt;구조체 배열&lt;/strong&gt;을 연습하고자 링크드 리스트를 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 정적이지만 동적할당처럼 사용하는 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 아래와 같이 사용할 수 있습니다.
Node* node = allocNode();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;cstring&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

// 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 메인 함수
int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);


	Node* head = '\0';
	char order[10];
	int count = 0;
	while (N--) {
		scanf(&quot;%s&quot;, order);

		if (order[1] == 'u') {
			int data;
			scanf(&quot;%d&quot;, &amp;amp;data);
			Node* node = allocNode();
			node-&amp;gt;data = data;

			if (count == 0) {
				head = node;
			} else {
				node-&amp;gt;next = head;
				head = node;
			}
			count++;
		} else if (order[0] == 'p') {
			if (head == '\0') {
				printf(&quot;%d\n&quot;, -1);
			} else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
				head = head-&amp;gt;next;
				count--;
			}
		} else if (order[0] == 's') {
			printf(&quot;%d\n&quot;, count);
		} else if (order[0] == 'e') {
			if (count == 0) {
				printf(&quot;%d\n&quot;, 1);
			} else {
				printf(&quot;%d\n&quot;, 0);
			}
		} else if (order[0] == 't') {
			if (count == 0) {
				printf(&quot;%d\n&quot;, -1);
			} else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
			}
		}
	};

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BOJ - 큐(10845)</title>
   <link href="http://localhost:4000/algorithm/2018/12/10/boj-queue-10845/"/>
   <updated>2018-12-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/12/10/boj-queue-10845</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;../backjoon-stack-10828/&quot;&gt;스택(10828)&lt;/a&gt;과 마찬가지로 간단한 &lt;strong&gt;링크드 리스트&lt;/strong&gt;를 이용해서 구현한 &lt;strong&gt;큐&lt;/strong&gt;입니다. 배열을 사용해서 더 간단하게도 구현 가능하지만 &lt;strong&gt;구조체 배열&lt;/strong&gt;을 연습하고자 링크드 리스트를 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;구조체-배열&quot;&gt;구조체 배열&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 정적이지만 동적할당처럼 사용하는 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeIndex = 0;
Node nodeArray[10000];
Node* allocNode() {
	return &amp;amp;nodeArray[nodeIndex++];
};

// 아래와 같이 사용할 수 있습니다.
Node* node = allocNode();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;전체-코드&quot;&gt;전체 코드&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

// 구조체 배열
typedef struct node {
	int data;
	node* next;
} Node;

int nodeidx = 0;
Node nodearray[10000];
Node* allocNode() {
	return &amp;amp;nodearray[nodeidx++];
};

// 메인 함수
int main() {

	int N;
	scanf(&quot;%d&quot;, &amp;amp;N);

	Node* head = '\0';
	Node* tail = '\0';

	char order[6];
	int count = 0;
	while (N--) {
		scanf(&quot;%s&quot;, order);

		// 새로운 노드 생성해서 큐에 PUSH
		if (order[1] == 'u') {
			int data;
			scanf(&quot;%d&quot;, &amp;amp;data);
			Node* node = allocNode();
			node-&amp;gt;data = data;
			if (count == 0) {
				head = node;
				tail = node;
			} else {
				tail-&amp;gt;next = node;
				tail = node;
			}
			count++;

		// 상위 노드(head) POP
		} else if (order[0] == 'p') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
				head = head-&amp;gt;next;
				count--;
			}

		// 큐에 있는 노드 갯수 출력
		} else if (order[0] == 's') {
			printf(&quot;%d\n&quot;, count);

		// 큐가 비어 있는지 확인
		} else if (order[0] == 'e') {
			if (count == 0) printf(&quot;1\n&quot;);
			else printf(&quot;0\n&quot;);

		// 상위 노드(head) 값 출력
		} else if (order[0] == 'f') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, head-&amp;gt;data);
			}

		// 마지막 노드(tail) 값 출력
		} else if (order[0] == 'b') {
			if (count == 0) printf(&quot;-1\n&quot;);
			else {
				printf(&quot;%d\n&quot;, tail-&amp;gt;data);
			}
		}
	};
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Example content</title>
   <link href="http://localhost:4000/daily/2018/12/01/example-content/"/>
   <updated>2018-12-01T00:00:00+09:00</updated>
   <id>http://localhost:4000/daily/2018/12/01/example-content</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Howdy! This is an example blog post that shows several types of HTML content supported in this theme.
&lt;/div&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis &lt;a href=&quot;#&quot;&gt;dis parturient montes&lt;/a&gt;, nascetur ridiculus mus. &lt;em&gt;Aenean eu leo quam.&lt;/em&gt; Pellentesque ornare sem lacinia quam venenatis vestibulum. Sed posuere consectetur est at lobortis. Cras mattis consectetur purus sit amet fermentum.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Curabitur blandit tempus porttitor. Nullam quis risus eget urna mollis ornare vel eu leo. Nullam id dolor id nibh ultricies vehicula ut id elit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Etiam porta &lt;strong&gt;sem malesuada magna&lt;/strong&gt; mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p&gt;

&lt;h2 id=&quot;inline-html-elements&quot;&gt;Inline HTML elements&lt;/h2&gt;

&lt;p&gt;HTML defines a long list of available inline tags, a complete list of which can be found on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&quot;&gt;Mozilla Developer Network&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;To bold text&lt;/strong&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;To italicize text&lt;/em&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Abbreviations, like &lt;abbr title=&quot;HyperText Markup Langage&quot;&gt;HTML&lt;/abbr&gt; should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, with an optional &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; attribute for the full phrase.&lt;/li&gt;
  &lt;li&gt;Citations, like &lt;cite&gt;— Mark otto&lt;/cite&gt;, should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Deleted&lt;/del&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; and &lt;ins&gt;inserted&lt;/ins&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Superscript &lt;sup&gt;text&lt;/sup&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sup&amp;gt;&lt;/code&gt; and subscript &lt;sub&gt;text&lt;/sub&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of these elements are styled by browsers with few modifications on our part.&lt;/p&gt;

&lt;h2 id=&quot;heading&quot;&gt;Heading&lt;/h2&gt;

&lt;p&gt;Vivamus sagittis lacus vel augue rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Morbi leo risus, porta ac consectetur ac, vestibulum at eros.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis &lt;code class=&quot;highlighter-rouge&quot;&gt;code element&lt;/code&gt; montes, nascetur ridiculus mus.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Example can be run directly in your JavaScript console

// Create a function that takes two arguments and returns the sum of those arguments
var adder = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);

// Call the function
adder(2, 6);
// &amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa.&lt;/p&gt;

&lt;h3 id=&quot;lists&quot;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur et.&lt;/li&gt;
  &lt;li&gt;Donec id elit non mi porta gravida at eget metus.&lt;/li&gt;
  &lt;li&gt;Nulla vitae elit libero, a pharetra augue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Donec ullamcorper nulla non metus auctor fringilla. Nulla vitae elit libero, a pharetra augue.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vestibulum id ligula porta felis euismod semper.&lt;/li&gt;
  &lt;li&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/li&gt;
  &lt;li&gt;Maecenas sed diam eget risus varius blandit sit amet non magna.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cras mattis consectetur purus sit amet fermentum. Sed posuere consectetur est at lobortis.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;HyperText Markup Language (HTML)&lt;/dt&gt;
  &lt;dd&gt;The language used to describe and define the content of a Web page&lt;/dd&gt;

  &lt;dt&gt;Cascading Style Sheets (CSS)&lt;/dt&gt;
  &lt;dd&gt;Used to describe the appearance of Web content&lt;/dd&gt;

  &lt;dt&gt;JavaScript (JS)&lt;/dt&gt;
  &lt;dd&gt;The programming language used to build advanced Web sites and applications&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Upvotes&lt;/th&gt;
      &lt;th&gt;Downvotes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;Totals&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alice&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bob&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Charlie&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Nullam id dolor id nibh ultricies vehicula ut id elit. Sed posuere consectetur est at lobortis. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/poole/poole/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
